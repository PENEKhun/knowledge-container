`JPA`는 통계와 같은 복잡한 쿼리를 위해 다음과 같은 쿼리 기술을 사용한다.
- 객체지향 쿼리
	- `JPQL`
	- `Criteria`
	- `QueryDSL`
- 그냥 쌩 SQL
	- `네이티브 쿼리`

`JPQL`**이 가장 핵심인 이유**는, `Criteria`, `QueryDSL`은 `JPQL`을 사용하기 쉽게 만드는 기술이기 때문이다. 따라서 우리는 `JPQL`을 필수적으로 학습해야한다.

# Criteria
`JPQL`을 생성하는 빌더 클래스다.

```java
CriteriaBuilder cb = em.getCriteriaBuilder();  
CriteriaQuery<MemberJPQL> query = cb.createQuery(MemberJPQL.class);  
  
CriteriaQuery<MemberJPQL> cq = query  
    .select(query.from(MemberJPQL.class))  
    .where(cb.equal(query.from(MemberJPQL.class).get("name"), "회원1"));  
  
List<MemberJPQL> resultList = em.createQuery(cq).getResultList();
```

사용 예를 보면 알겠지만, 빌더 패턴을 통해 SQL을 JAVA 코드처럼 작성할 수 있다. 컴파일 단계에서 오탈자를 경고받고 싶다면, 메타 모델을 생성해주는 `hibernate-jpamodelgen`을 사용하면 된다.

코드로 작성하기 때문에 JPQL보단 편하지만 한눈에 잘 읽히진 않는다.
# QueryDSL
`Criteria` 처럼 `JPQL` 빌더 역할을 한다. `Criteria`과는 달리 한눈에 읽힌다는 장점이 있다.

# 네이티브 쿼리
```java
asd
```


# JPQL (객체지향 SQL)
우리는 `ORM`을 사용하기 때문에, `Table`이 아닌 `엔티티 객체`를 다룬다. **따라서 데이터를 검색할때 테이블이 아닌 엔티티 객체 대상으로 검색되어야 한다.** 이러한 배경에서 나오게 된것이 `JPQL`이다.

`JPQL`의 특징은 다음과 같다.
- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않음

기본적으로 이렇게 사용한다.
```java
String jpql1 = "select m from MemberJPQL m where m.name = '회원1'";  
List<MemberJPQL> resultList = em.createQuery(jpql1, MemberJPQL.class)  
    .getResultList();
```

`JPQL`이 `SQL`과 비슷하다고 생각할 수 있다. 하지만 `JPQL`은 엔티티 직접 조회, [묵시적 조인](JPQL%20묵시적%20조인.md), 다형성 지원으로 **SQL보다 간결하다.**





