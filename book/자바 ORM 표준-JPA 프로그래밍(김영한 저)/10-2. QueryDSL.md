# Dependencies
기준 : 스프링부트 3.0 이상

```java
plugins {  
	// ... 생략
	
    id 'io.spring.dependency-management' version '1.1.0'  
}

dependencies {
	// ... 생략
	
	implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
	annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta"  
	annotationProcessor "jakarta.annotation:jakarta.annotation-api"  
	annotationProcessor "jakarta.persistence:jakarta.persistence-api"
}
```

위 처럼 추가하면 빌드마다 어노테이션 프로세서가 동작하여 generated 하위 디렉터리에 `QClass`가 생성된다.

![qclass_generated|300](/assets/book/orm/10-1/qclass_generated.png)

생성된 `QClass`는 대충 다음처럼 생겼다.
```java
/**  
 * QDib is a Querydsl query type for Dib
 **/
 @Generated("com.querydsl.codegen.DefaultEntitySerializer")  
public class QDib extends EntityPathBase<Dib> {  
  
    private static final long serialVersionUID = 1305407739L;  
  
    public static final QDib dib = new QDib("dib");  
  
    public final NumberPath<Integer> accountId = createNumber("accountId", Integer.class);  
  
    public final DateTimePath<java.time.LocalDateTime> createdAt = createDateTime("createdAt", java.time.LocalDateTime.class);  
  
    public final NumberPath<Integer> id = createNumber("id", Integer.class);  
  
    public final NumberPath<Integer> productId = createNumber("productId", Integer.class);  
  
    public final NumberPath<Integer> selectShopId = createNumber("selectShopId", Integer.class);  
  
    public QDib(String variable) {  
        super(Dib.class, forVariable(variable));  
    }  
  
    public QDib(Path<? extends Dib> path) {  
        super(path.getType(), path.getMetadata());  
    }  
  
    public QDib(PathMetadata metadata) {  
        super(Dib.class, metadata);  
    }  
  
}
```

그리고 `JPAQueryFactory`를 주입받아 사용하면 된다.
```java
@Repository  
@RequiredArgsConstructor  
public class DibRepository {  
    private final JPAQueryFactory queryFactory;

	public boolean isProductDib(int accountId, int productId) {  
	    if (accountId == 0) return false; // 비회원은 상품 찜 불가  
	  
	    QDib dib = QDib.dib;  
	    return queryFactory  
	            .selectFrom(dib)  
	            .where(dib.accountId.eq(accountId)  
	                    .and(dib.productId.eq(productId)))  
	            .fetchFirst() != null;  
	}
}
```


# 사용 예시

## 실습을 위한 엔티티
```java
public class Product {  
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Integer id;  
    private String name;  
    private Integer price;  
    private String url;  
    private String description; 
  
    @ManyToOne(fetch = FetchType.LAZY)  
    private SelectShop selectShop;  
 
    @Builder.Default  
    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)  
    private List<ImageProduct> images = new ArrayList<>();  
  
    @CreatedDate  
    @Column(name = "created_at")  
    private Instant createdAt;
}
```


## 조회
```java
// 10,000원 이상의 아디다스 삼선슬리퍼 검색  
QProduct product = QProduct.product;  
List<Product> products = queryFactory.selectFrom(product)  
    .where(product.name.eq("아디다스 삼선슬리퍼")  
        .and(product.price.gt(10000)))  
    .fetch();
```

혹은 **And연산자**를 **생략**해도 된다.

```java
// 10,000원 이상의 아디다스 삼선슬리퍼 검색  
QProduct product = QProduct.product;  
List<Product> products = queryFactory.selectFrom(product)  
    .where(product.name.eq("아디다스 삼선슬리퍼"),  
        product.price.gt(10000))   // and 대신 , 가 사용됨
    .fetch();
```

where절에서 쓰기 좋은 메소드
- beetween
```java
// 가격이 10000~20000인 상품을 검색
.where(product.price.between(10000, 20000))  
```
- contains
```java
// 상품명에 나이키가 들어간 상품
.where(product.name.contains("나이키"))  
```
SQL에서 **%나이키%** 와 같다.
- startsWith
```java
// 나이키로 시작하는 상품
.where(product.name.startsWith("나이키"))  
```
SQL에서 **나이키%** 와 같다.

### 검색 결과 사용
- fetchOne
	- 검색결과를 하나 가져온다.
	- 검색결과가 없으면 `NULL`, 둘 이상이면 `NonUniqueResultException` 예외
- fetchFirst
	- Limit 1로 fetchOne을 함.
	- 처음 한건을 가져올 때 사용
	```java
public final T fetchFirst() {  
  return ((FetchableQueryBase)this.limit(1L)).fetchOne();  
}
	```
- fetch
	- 리스트로 결과 반환 (없으면 빈 컬렉션)
- fetchResults
> 	Deprecated


## 페이징과 정렬
`offset`, `limit`를 사용하여 페이징 처리를 하고, `orderBy`를 통해 정렬을 함.
```java
queryFactory.selectFrom(product)  
    .where(product.name.eq("나이키")) 
    .orderBy(product.price.desc()) 
    .offset(0)  
    .limit(10)  
    .fetch();
```


또는 `QueryModifiers`를 통해 페이징 처리를 해도 된다.
```java
// limit 10, offset 0
QueryModifiers queryModifiers = new QueryModifiers(10L, 0L);  
queryFactory.selectFrom(product)  
    .where(product.name.eq("나이키"))  
    .orderBy(product.price.desc())  
    .restrict(queryModifiers) // QueryModifier 등록 
    .fetch();
```

인자로 `Pageable`을 받아서 `limit`,` offset`을 넣어주는게 많이 사용하는 방식인듯 하다. 이렇게 하면 페이지 객체 만들기도 편하다.

```java
public PageImpl<Product> page(Pageable pageable){  
  List<Product> a = queryFactory.selectFrom(product)  
      .where(product.name.eq("나이키"))  
      .orderBy(product.price.desc())  
      .limit(pageable.getPageSize())  
      .offset(pageable.getOffset())  
      .fetch();  
  
  return new PageImpl<>(a, pageable, a.size());
```

