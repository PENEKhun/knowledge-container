JPA 에서 #연관관계 를 조회할때는 `지연로드`(*LAZY*), `즉시로드`(*EAGER*) 방식이 있다.
기본적으로 즉시로드로 설정되어 있다. 지연로드 방식으로 변경 하려면 다음처럼 `fetch`값을 변경한다.

```java
@Entity  
public class Member {  
//..
  @ManyToOne(fetch = FetchType.LAZY) // <- 요렇게
  private Team team;
//..
}
```

## #지연로드
`지연로드`는 값을 실제로 필요로 할때 조회가 이뤄지는 것이다. 

```java
@Entity  
public class Member {  
//..
  @ManyToOne(fetch = FetchType.LAZY)
  private Team team;
//..
}
```

```java
@Entity
public class Team {  
//..  
  private String name;
}
```

이러한 *엔티티 도메인*에서 *PK*가 1인 **Member**를 조회하면, 소스코드는 아래와 같다.

```
Member member1 = entityManager.find(Member.class, 1L);  
System.out.println("사람 이름을 출력합니다. -> " + member1.getName());  
System.out.println("팀 이름을 출력합니다. -> " + member1.getTeam().getName());
```

**출력된 결과**를 확인하면 아래와 같다.

```
Hibernate: select m1_0.id,m1_0.age,m1_0.name,m1_0.team_id from member m1_0 where m1_0.id=?
사람 이름을 출력합니다. -> 1번 타자 홍길동
Hibernate: select t1_0.id,t1_0.name from team t1_0 where t1_0.id=?
팀 이름을 출력합니다. -> LG Twins
```

여기서 눈 여겨볼 포인트는...
- 처음부터 Member 접근할때 Team까지 조회하지 않았다. (_출력된 결과 line 1_)
```
Hibernate: select m1_0.id,m1_0.age,m1_0.name,m1_0.team_id from member m1_0 where m1_0.id=?
```

- 실제 **Team** 값을 **Access**하려고 하자, Team조회 쿼리가 나갔다. (_출력된 결과 line 3-4_)
```
사람 이름을 출력합니다. -> 1번 타자 홍길동
Hibernate: select t1_0.id,t1_0.name from team t1_0 where t1_0.id=?
팀 이름을 출력합니다. -> LG Twins
```
> member1.getTeam().getName() 이 호출될때 그제서야 쿼리가 나감.

값에 언제 접근할지 어떻게 알고 **지연로드**가 동작하는걸까?


## #즉시로드
앞서 말했듯 기본적으론 즉시로드를 한다.

