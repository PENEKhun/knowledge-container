# 43~54강
## 데이터

![[image-and-container-rw.png]]
> 47강 3' 30"

### 기본적인 도커의 데이터 관리
- 이미지는 ReadOnly임.
- 만약에 컨테이너가 실행되면서 쓰기작업이 필요한 경우(임시 appData 혹은 영구데이터), 이미지가 아닌 컨테이너안에 데이터가 추가됨.
	- 그렇기때문에 컨테이너를 중단하고 재시작해도 컨테이너안에 데이터가 잘 남아있음.
	- 하지만 컨테이너에 `--rm` 옵션이 있으면 중단과 동시에 삭제되기 때문에 데이터도 같이 지워짐.

#### 개선점(볼륨)
[[#기본적인 도커의 데이터 관리]]에선 이미지를 재빌드하여 컨테이너를 새롭게 생성&실행하면, 기존 컨테이너에 있던 데이터는 사라진다. 이러한 문제를 해결하기 위해 [[#개선점(볼륨)|볼륨]]을 사용한다.
- **컨테이너에 볼륨을 추가하면, 컨테이너가 제거되어도 볼륨이 유지됨!!**
	- **그 말은, 컨테이너 외부에서 액세스할 수 도 있다는 말임!!**

- Anonymous Volumes
> 실제로 로컬호스트에 어떤 경로로 미러링되는지 모름.

 *->* `--rm`으로 컨테이너를 시작하면, 익명 볼륨도 사라짐.
 *--->* 그렇지 않으면, 익명 볼륨이 계속 쌓임. `docker volume rm {}` 혹은 `docker volume prune`으로 삭제해줘야함.
 
 Dockerfile에서 정의
```dockerfile
VOLUME [ "/app/feedback" ] <- 외부로 드러낼 컨테이너 안에 내부 위치
```

혹은 cli에서
```bash
docker run .... -v {컨테이너 내부 경로}
```

- Named Volumes
 > 영구적으로 보관이 필요한 데이터가 있을 경우 사용.

-> 어떻게든 컨테이너가 제거되어도, 볼륨은 남아있음. (맞나??)
-> Named Volumes는 Dockerfile에서 정의하는 것이 아닌, docker cli에서 정의하는 것.
*->* 수정은 불가능함. 왜냐면 로컬 머신내 어디에 저장될지 모르니깐.
```bash
docker run .... -v "{지정할_볼륨이름}:{컨테이너 내부 경로}"
// 콜론앞에 경로가 아닌게 붙으면, 네임드 볼륨이 됨
```

- Bind Mounts
> 로컬 호스트내 특정 위치를 컨테이너로 마운트함

- 주의사항 : 기존 컨테이너 내 경로를 로컬경로로 완전 대체함.
```bash
docker run .... -v "{로컬경로}:{컨테이너 내부 경로}"
// 콜론앞에 경로가 아닌게 붙으면, 네임드 볼륨이 됨
```

---
# 55~66 강 
도커 -v를 사용하는 3가지 방법
![[Pasted image 20241108152241.png]]

| 볼륨 유형     | 익명 볼륨                             | 이름이 있는 볼륨                               | 바인드 마운트                                     |
| --------- | --------------------------------- | --------------------------------------- | ------------------------------------------- |
| 생성 목적     | 특정 컨테이너에 대해 생성됨                   | 일반적으로 생성됨 – 특정 컨테이너에 종속되지 않음            | 호스트 파일 시스템의 위치 – 특정 컨테이너에 종속되지 않음           |
| 지속성       | 컨테이너 종료/재시작 시 유지 (`--rm` 사용 시 삭제) | 컨테이너 종료/재시작 시 유지<br>– Docker CLI로 삭제 가능 | 컨테이너 종료/재시작 시 유지<br>– 호스트 파일 시스템에서 삭제 가능    |
| 공유 가능 여부  | 다른 컨테이너와 공유 불가                    | 다른 컨테이너와 공유 가능                          | 다른 컨테이너와 공유 가능                              |
| 재사용 가능 여부 | 익명이므로 재사용 불가 (같은 이미지에서도 사용 불가)    | 동일한 컨테이너에서 재사용 가능 (재시작 포함)              | 동일한 컨테이너에서 재사용 가능 (재시작 포함)                  |
| 사용 예시     | `docker run -v /app/data ...`     | `docker run -v data:/app/data ...`      | `docker run -v /path/to/code:/app/code ...` |

readyonly -> :ro
-v 옵션엔 **Hierarchy**(이 용어가 맞나 ?)가 존재함.
작은 개념(작은 폴더)가 오버라이팅


59장 에매함. `COPY . .` 이 부분

`.dockerignore` 를 사용하는 이유
- 이미지를 빌드할때 COPY에서 제외할 디렉토리/파일 명시
	- ![[Pasted image 20241108173350.png]]
고려사항
- 이미지 사이즈를 최대한 줄일 수 있도록 하자 -> 빌드시간 감소 등등
	- 자주쓰이는 `npm install` 같은 경우엔 도커에서 자체적으로 캐싱할 수 도 있으니깐 이미지 사이즈가 획기적으로 감소되는 그런 케이스가 있을수도 있음.
- Dockerfile, .git 무시, 그 외에도 민감정보 등등 제외



- arg와 env.
> 좀 더 유연한 이미지와 컨테이너를 만들때 사용

애플리케이션에서 다루는 API KEY 등등...을 주입해서 쓰면 편하겠군~!

| 변수 유형 | **ARG**ument                                                  | **ENV**iorment                                       |
| ----- | ------------------------------------------------------------- | ---------------------------------------------------- |
| 설명    | - Dockerfile 내부에서만 사용 가능(빌드시점)<br>- CMD 또는 애플리케이션 코드에서는 접근 불가 | - Dockerfile 및 애플리케이션 코드에서 사용 가능                     |
| 설정 방법 | 이미지 빌드 시 설정 (`docker build`의 `--build-arg` 옵션 사용)             | Dockerfile의 `ENV` 명령어 또는 `docker run`의 `--env` 옵션 사용 |
| 사용 예시 | Dockerfile를 수정하지 않고, 여러개의 값을 가진 다양한 이미지를 만들고 싶을때              | 하나의 이미지로 유연한 변수를 가지는 컨테이너로 실행하고 싶을때                  |
| 주의사항  | 이것도 도커 레이어를 추가함.<br>그래서 캐싱전략을 위해 순서를 잘 조작해야함.                 |                                                      |

- ENV
사용법 :
```dockerfile
ENV {환경변수_이름} {기본_값}
```

활용예시 :
```dockerfile
ENV PORT 80
EXPOSE $PORT // 도커파일에서 환경변수를 사용할때 `$이름` 사용
```

```bash
docker run .... --env PORT=8080

또는

docker run .... -e PORT=8080

또는 

docker run .... --env-file ./.env
// .env 파일에 PORT=8080
```
```